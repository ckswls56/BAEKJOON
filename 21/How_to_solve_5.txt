어떤 수로 나머지 연산을 하고자 할떄, 그 수의 곱셈에 대한 역원을 찾고 그역원을 곱해주는것으로
나눗셈을 수행한다. 일반 나눗셈을 할때 a로나눠주는것을 1/a 로 곱해주는것과 같은 이치이다.

정수 a를 m으로 나눈 나머지 연산의 곱셈 역원은 a * a^-1 = 1 (mod m) 을 만족해야한다.
즉 a^-1 = x (mod m)을 만족하는 x를 말한다.
역원은 a와 m이 서로소인 경우에만 존재한다 (gcd(a,m)=1)
아래와 같이 역원을 구할 수 있다.
for(int i=1;i<m;i++){
    if((a*i) % m == 1)
        x=i;
}
하지만 이 코드는 시간복잡도가 O(m)이므로 더빠른 알고리즘을 이용하여야 한다.
(나누고자 하는 수가 무수히 클 수 있으므로)

첫번째 방법으로는 확장 유클리드 알고리즘이 있다. 
확장 유클리드 호제법을 공부하기 전에 먼저 베주 항등식을 알아야 하는데 그 이유는 확장 유클리드 호제법이 
베주 항등식의 명제를 가정으로 하여 해를 구하는 방법이기 때문이다.
gcd(a,b)=d 라고 할때
ax+by = d를 만족하는 정수 x,y 가 존재한다.
유클리드 호재법의 과정을 역으로 따라가면 이 x,y의 해를 구할 수 있다.
그러나 우리는 역원을 구하기 위하여 gcd(1)일때의 x,y의 해를 구하면 된다.

두번쨰 방법으로는 페르마의 소정리가 있다.
m 이 소수(prime number)이고 a와 m이 서로소라면 a^m-1은 m으로 나눈 나머지는 항상 1이다.
즉 a^m-1=1(mod m) 이고 a*a^m-2 = 1(mod m)이다.
즉 a^m-2 이 역원이 된다.

5.c에서는 이항계수를 1,000,000,007 이라는 큰수를 나머지연산한 값을 출력하는것이다.
즉 N!/(K!(N-K)!) % M(1,000,000,007) 을 구해야한다.
A=N! B=K!(N-K)!이라 치환하면 A/B (mod M)  이고 모듈러 곱셈의 원리에 의해
((A mod M ) * (B mod M)^-1 ) mod M 이 되며 
A의 최대값은 4,000,000  이므로 그냥 A로 나오게 되고 , B는 M이 소수이므로 두번쨰 방법인 페르마의 소정리를 이용할 수 있다.
A*B^m-2 (mod M) 을 계산하면 된다.

분할정복을 이용하면 거듭제곱을 logn번에 연산이 가능하다.




